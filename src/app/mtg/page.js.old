"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { fetchSets, fetchSetCards, fetchMoreCards } from '../services/Scryfall.js';
import { loadCollection, saveCollection } from "../services/Collection.js";
import { fetchCardPrice } from "../services/pricing.js";
import { exportToJSON } from "../services/Export.js";
import Card from "../components/Card.js";
import { useCurrencyContext } from "@/context/";
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";
import styles from "./page.module.css";

// Fonction pour récupérer le dernier prix connu
const getLastPrice = (card, currency) => {
  if (!card.priceHistory || card.priceHistory.length === 0) {
    return 0;
  }
  return card.priceHistory.slice(-1)[0][currency] || 0;
};

export default function Collection() {

  const [collection, setCollection] = useState([]);
  const [sets, setSets] = useState([]);
  const [updating, setUpdating] = useState(false);
  const [summary, setSummary] = useState({ totalCards: 0, totalValue: 0 });
  const [collectionHistory, setCollectionHistory] = useState([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [sortOption, setSortOption] = useState("name");
  const [selectedSet, setSelectedSet] = useState("");
  const [filters, setFilters] = useState({
    minPrice: 0,
    maxPrice: 0,
    set: "",
    type: "",
    color: "" 
  });
  const { currency, toggleCurrency } = useCurrencyContext();

  useEffect(() => {
    const loadSets = async () => {
      const allSets = await fetchSets();
      console.log(allSets)
      setSets(allSets);
    };
    loadSets();
  }, []);


  const updateQuantity = (cardId, delta) => {
    const updatedCollection = collection.map((card) =>
      card.id === cardId
        ? { ...card, quantity: Math.max(1, card.quantity + delta) }
        : card
    );
    setCollection(updatedCollection);
    saveCollection(updatedCollection);
  };

  useEffect(() => {console.log(collection)});

  const handleSearchChange = (event) => {
    setSearchQuery(event.target.value.toLowerCase());
  };
  
  const filteredCollection = collection.filter((card) =>
    card.name.toLowerCase().includes(searchQuery)
  );

  const sortCollection = (cards) => {
    return [...cards].sort((a, b) => {
      switch (sortOption) {
        case "price":
          return parseFloat(a.priceHistory.at(-1)[currency]) - parseFloat(b.priceHistory.at(-1)[currency]);
        case "name":
          return a.name.localeCompare(b.name);
        case "date":
          return new Date(a.addedAt) - new Date(b.addedAt);
        case "set":
          return a.set.localeCompare(b.set);
        case "color":
          return (a.colors[0] || "").localeCompare(b.colors[0] || "");
        default:
          return 0;
      }
    });
  };

const sortedCollection = sortCollection(filteredCollection);

const handleFilterChange = (key, value) => {
  setFilters((prev) => ({ ...prev, [key]: value }));
};

const filteredAndSortedCollection = sortedCollection.filter((card) => {
  const lastPrice = parseFloat(card.priceHistory.at(-1)[currency]);
  return (
    lastPrice >= filters.minPrice &&
    lastPrice <= filters.maxPrice && 
    (filters.set ? card.set === filters.set : true) &&
    (filters.type ? card.type_line.includes(filters.type) : true) &&
    (filters.color ? card.colors.includes(filters.color) : true)
  );
});

  const removeCard = (cardId) => {
    const updatedCollection = collection.filter((card) => card.id !== cardId);
    setCollection(updatedCollection);
    saveCollection(updatedCollection);
  };

  useEffect(() => {console.log("nombre de renders")});

  useEffect(() => {
    const loadedCollection = loadCollection();
    console.log(loadedCollection)
    setCollection(loadedCollection);

    setSummary(calculateCollectionStats(loadedCollection, currency));
    setCollectionHistory(generateCollectionValueHistory(loadedCollection, currency));
  }, [currency]);

  useEffect(() => {
    setSummary(calculateCollectionStats(collection, currency));
    setCollectionHistory(generateCollectionValueHistory(collection, currency));
  }, [collection]);

  const handleExport = () => {
    if (collection.length === 0) {
      alert("Aucune carte à exporter !");
      return;
    }
    exportToJSON(collection, "fondations-mtg.json");
  };

  // Fonction pour mettre à jour les prix
  const updatePrices = async () => {
    setUpdating(true);
    const today = new Date().toISOString().split("T")[0];

    const updatedCollection = await Promise.all(
      collection.map(async (card) => {
        const newPrice = await fetchCardPrice(card.name);
        const lastEntry = card.priceHistory.slice(-1)[0];

        // Si la date du dernier enregistrement est différente d'aujourd'hui, ajouter une nouvelle entrée
        if (!lastEntry || lastEntry.date !== today) {
          card.priceHistory.push({
            date: today,
            usd: newPrice.usd || 0,
            eur: newPrice.eur || 0,
          });
        }

        return { ...card };
      })
    );

    setCollection(updatedCollection);
    saveCollection(updatedCollection);
    setUpdating(false);
  };

  const calculateCollectionStats = (collection, currency) => {
    let totalCards = 0;
    let totalValue = 0;
  
    collection.forEach(card => {
      totalCards += card.quantity;
      const lastPrice = card.priceHistory.length > 0 ? parseFloat(card.priceHistory.at(-1)[currency]) : 0;
      totalValue += lastPrice * card.quantity;
    });
  
    return { totalCards, totalValue: totalValue.toFixed(2) };
  };

  const generateCollectionValueHistory = (collection, currency) => {
    const historyMap = new Map();
  
    collection.forEach(card => {
      card.priceHistory.forEach(({ date, eur, usd }) => {
        const price = currency === "eur" ? parseFloat(eur) : parseFloat(usd);
        if(price > filters.maxPrice) setFilters((prev) => ({ ...prev, ["maxPrice"]: price }));
        const totalValueForCard = price * card.quantity;
  
        if (!historyMap.has(date)) {
          historyMap.set(date, 0);
        }
        historyMap.set(date, historyMap.get(date) + totalValueForCard);
      });
    });
  
    return Array.from(historyMap.entries()).map(([date, totalValue]) => ({ date, totalValue: totalValue.toFixed(2) }));
  };

  const uniqueSetCodes = [...new Set(collection.map((card) => card.set))];

  const getSetName = (setCode) => {
    const foundSet = sets.find((set) => set.code === setCode);
    return foundSet ? foundSet.name : "Nom inconnu";
  };

  const handleSelectedSet = (setCode) => {
    console.log(setCode)
    setSelectedSet(setCode);
  };

  return (
    <div id={styles.collectionPage}>
      <Link className={styles.addCardsBtn} href="/mtg/importer">
        Importer de nouvelles cartes
      </Link>
      <h1>Ma Collection</h1>
      <p><strong>Nombre total de cartes :</strong> {summary.totalCards}</p>
      <p><strong>Valeur actuelle :</strong> {summary.totalValue} {currency === "eur" ? "€" : "$"}</p>
      <ResponsiveContainer width="80%" height={300}>
        <LineChart data={collectionHistory}>
          <XAxis dataKey="date" />
          <YAxis domain={[0, Number(summary.totalValue)+1]}/>
          <Tooltip />
          <Line type="monotone" dataKey="totalValue" stroke="#8884d8" />
        </LineChart>
      </ResponsiveContainer>
      <div className={styles.buttonContainer}>
        <button className={styles.update} onClick={toggleCurrency}>
          Afficher en {currency === "eur" ? "USD $" : "EUR €"}
        </button>
        <button className={styles.update} onClick={updatePrices} disabled={updating}>
          {updating ? "Mise à jour en cours..." : "Mettre à jour les prix"}
        </button>
        <button onClick={handleExport}>Export to JSON</button>
      </div>

      {/* <input
        type="text"
        placeholder="Rechercher une carte..."
        value={searchQuery}
        onChange={handleSearchChange}
      /> */}

      {collection && (
        <div className={styles.setsContainer}>
        {uniqueSetCodes.map((setCode, index) => (
          <div className={styles.setNames} key={index} onClick={() => handleSelectedSet(setCode)}>{getSetName(setCode)}</div>
        ))}
        </div>
      )}

      {/* <select value={sortOption} onChange={(e) => setSortOption(e.target.value)}>
        <option value="name">Nom (A-Z)</option>
        <option value="price">Prix</option>
        <option value="date">Date d'ajout</option>
        <option value="set">Set</option>
        <option value="color">Couleur</option>
      </select>

    <div>
      <label>Prix min:</label>
      <input type="number" value={filters.minPrice} onChange={(e) => handleFilterChange("minPrice", e.target.value)} />

      <label>Prix max:</label>
      <input type="number" value={filters.maxPrice} onChange={(e) => handleFilterChange("maxPrice", e.target.value)} />
    </div>

      <div className={styles.rangeSlider}>
        <input value={filters.minPrice} min="0" max="20" step="1" type="range" onChange={(e) => handleFilterChange("minPrice", e.target.value)}/>
        <input value={filters.maxPrice} min="0" max="20" step="1" type="range" onChange={(e) => handleFilterChange("maxPrice", e.target.value)}/>
      </div>

    <div>
      <label>Set:</label>
      <input type="text" value={filters.set} onChange={(e) => handleFilterChange("set", e.target.value)} />

      <label>Type:</label>
      <input type="text" value={filters.type} onChange={(e) => handleFilterChange("type", e.target.value)} />

      <label>Couleur:</label>
      <input type="text" value={filters.color} onChange={(e) => handleFilterChange("color", e.target.value)} />
    </div> */}

      <div className={styles.cardContainer}>

        {filteredAndSortedCollection.length === 0 && <p>Votre collection est vide.</p>}
        {filteredAndSortedCollection.map((card) => {
          const isDoubleFaced = !!card.image?.front && !!card.image?.back;

          return (
            <Card
              key={card.id}
              card={{
                ...card,
                price: getLastPrice(card, currency), // Utilisation du dernier prix
                image_uris: {
                  small: isDoubleFaced ? card.image.front.small : card.image.small,
                  normal: isDoubleFaced ? card.image.front.normal : card.image.normal,
                  large: isDoubleFaced ? card.image.front.large : card.image.large,
                },
              }}
              updateQuantity={updateQuantity}
              onRemove={removeCard}
              currency={currency}
            />
          );
        })}
      </div>
    </div>
  );
}